#+PROPERTY: header-args :tangle out/Poly.hs :mkdirp true :session poly :comments link

* Poor Polynomials

  #+begin_src haskell :session none
    {-# LANGUAGE ViewPatterns #-}

    module Poly where
  #+end_src

  #+begin_src haskell
    import Data.Coerce (coerce)
    import Data.Monoid (Sum (..))
    import Data.List (intersperse, foldl')
    import Data.Maybe (catMaybes, isJust)
  #+end_src

  #+begin_quote

  We want to represent polynomials using lists, such that the
  coefficients are stored from the most significant to the least
  significant. That is, the polynomial

    2x^3 - 3x^2 + 7

  would be represented as

    [2,-3,0,7]
  #+end_quote

  #+begin_src haskell
    newtype Poly = Poly {unPoly :: [Int]}
  #+end_src

* Properties of ~Poly~

    * (1 points) The toPoly function allows you to receive an
      arbitrary list of numbers and "convert" it into a Poly.
    * (1 points) The Show instance shows the polynomials in algebraic
      notation instead of a simple list.
    * (1 point) The addPoly p0 p1 function allows adding two
      polynomials.
    * (2 points) The evalPoly p x function allows to evaluate the
      value of the polynomial p at point x.

    You cannot use length or reverse in its implementation. To obtain
    all the points, the implementation of each function has to make a
    single pass through the list that internally represents the
    polynomial.

    #+begin_src haskell
      toPoly :: [Int] -> Poly
      toPoly = Poly . foldr (\x -> (<> [x])) []

      showTerm :: Int -> Int -> [String]
      showTerm exp 0     = []
      showTerm 0   coeff = [show coeff]
      showTerm exp coeff = [show coeff <> "x^" <> show exp]

      instance Show Poly where
        show = coerce
          (unwords . intersperse "+" . foldr (\(e, c) -> (<> showTerm e c)) [] . zip [0..])

      addTerm :: Maybe Int -> Maybe Int -> Maybe Int
      addTerm (coerce -> x) (coerce -> y) = coerce ((x <> y) :: Maybe (Sum Int))

      addPoly :: Poly -> Poly -> Poly
      addPoly (Poly p1) (Poly p2) =
        Poly (catMaybes (takeWhile isJust (zipWith addTerm (fill p1) (fill p2))))
        where fill p = fmap Just p <> repeat Nothing

      evalTerm :: Int -> Int -> Int -> Int
      evalTerm v exp coeff = coeff * (v ^ exp)

      evalPoly :: Poly -> Int -> Int
      evalPoly (Poly p) x =
        coerce (foldMap (Sum . uncurry (evalTerm x)) (zip [0..] p))
    #+end_src

* Examples

    #+begin_src haskell
      example1 :: Poly
      example1 = toPoly [1, 2, 3]

      example2 :: Poly
      example2 = toPoly [1, -2, 3]

      example3 :: Poly
      example3 = toPoly [-1, -2, -3]

      example4 :: Poly
      example4 = toPoly [-1, 0, -2, 1]

      example5 :: Poly
      example5 = toPoly [1, -1]

      example6 :: Poly
      example6 = toPoly [1, 1]
    #+end_src

* Multiplication

  #+begin_src haskell
    distributeTerm :: Poly -> Int -> Int -> Poly
    distributeTerm p exp coeff  =
      Poly (replicate exp 0 <> fmap (* coeff) (coerce p))

    distributePoly :: Poly -> Poly -> [Poly]
    distributePoly p1 p2 = zipWith (distributeTerm p2) [0..] (coerce p1)

    multPoly :: Poly -> Poly -> Poly
    multPoly p1 p2 = foldl' addPoly (Poly []) (distributePoly p1 p2)
  #+end_src

* Are ~Poly~'s some kind of existing structure?

  This seems ok, but is kind of... not good?

  #+begin_src haskell
    instance Num Poly where
      (+) = addPoly
      (*) = multPoly
      fromInteger = Poly . pure . fromInteger
      negate (Poly p) = Poly (fmap negate p)
       -- I don't know what these two are
      abs = undefined
      signum = undefined
  #+end_src
